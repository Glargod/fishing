<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Solar Wind Live Meter</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/suncalc/1.9.0/suncalc.min.js"></script>
<style>
body {
    font-family: Arial, sans-serif;
    background-color: #1a1a1a;
    color: #ffffff;
    margin: 20px;
}
.container {
    max-width: 800px;
    margin: auto;
    padding: 20px;
    background-color: #2c2c2c;
    border-radius: 10px;
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
}
.section {
    margin-bottom: 20px;
}
.data-item {
    margin: 5px 0;
}
#kpChartContainer {
    width: 300px;
    height: 300px;
    margin: 0 auto 20px;
}
#issFeed {
    width: 100%;
    height: 300px;
    border: none;
}
.iframe-fallback {
    color: #ffca28;
    text-align: center;
}
.forecast-table {
    width: 100%;
    border-collapse: collapse;
}
.forecast-table th, .forecast-table td {
    padding: 8px;
    border: 1px solid #555;
    text-align: left;
}
.forecast-table th {
    background-color: #3a3a3a;
}
.alert-marquee {
    display: none;
    background: linear-gradient(45deg, #ff0000, #00ff00, #ff0000);
    color: #fff;
    padding: 10px;
    font-weight: bold;
    text-align: center;
    animation: flash 1s infinite, marquee 10s linear infinite;
    border-radius: 5px;
    margin-bottom: 20px;
}
@keyframes flash {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.7; }
}
@keyframes marquee {
    0% { transform: translateX(100%); }
    100% { transform: translateX(-100%); }
}
.photo-tips {
    background-color: #3a3a3a;
    padding: 10px;
    border-radius: 5px;
}
#kpNumber {
    font-size: 48px;
    font-weight: bold;
    text-align: center;
    margin-top: 10px;
    transition: text-shadow 0.3s ease;
}
.kp-glow-yellow {
    text-shadow: 0 0 10px #FFCA28, 0 0 20px #FFCA28;
}
.kp-glow-red {
    text-shadow: 0 0 15px #F44336, 0 0 30px #F44336, 0 0 45px #F44336;
}
</style>
</head>
<body>
<div class="container">
<h1>Solar Wind Live Meter</h1>
<div class="section" id="timestamp">As of: Loading...</div>

<div class="section">
<div id="optimalAlert" class="alert-marquee">
ðŸŒŒ Optimal Viewing Conditions! Look Up to Observe Stars or Aurora! ðŸŒŒ
</div>
</div>

<div class="section" id="kpChartContainer">
<canvas id="kpChart"></canvas>
<div id="kpNumber">0</div>
</div>

<div class="section">
<h2>Solar Wind Data</h2>
<div class="data-item">Speed: <span id="speed">Loading...</span> km/s</div>
<div class="data-item">Density: <span id="density">Loading...</span> p/cmÂ³</div>
<div class="data-item">IMF Bz: <span id="bz">Loading...</span> nT</div>
</div>

<div class="section">
<h2>Flare Probabilities</h2>
<div class="data-item">C Flare: <span id="cFlare">Loading...</span>%</div>
<div class="data-item">M Flare: <span id="mFlare">Loading...</span>%</div>
<div class="data-item">X Flare: <span id="xFlare">Loading...</span>%</div>
<div class="data-item">Proton Event: <span id="proton">Loading...</span>%</div>
</div>

<div class="section">
<h2>Astronomical Data (<span id="timezone">Detecting...</span>)</h2>
<div class="data-item">Sun: Rise <span id="sunRise">Loading...</span>, Set <span id="sunSet">Loading...</span></div>
<div class="data-item">Moon: Rise <span id="moonRise">Loading...</span>, Set <span id="moonSet">Loading...</span>, Illum <span id="moonIllum">Loading...</span>%</div>
</div>

<div class="section">
<h2>Weather Forecast (<span id="location">Detecting...</span>)</h2>
<table class="forecast-table">
<thead>
<tr>
<th>Date</th>
<th>Condition</th>
<th>High (Â°C)</th>
<th>Low (Â°C)</th>
<th>Precipitation (%)</th>
<th>Wind (km/h)</th>
</tr>
</thead>
<tbody id="forecastBody">
<tr><td colspan="6">Loading...</td></tr>
</tbody>
</table>
</div>

<div class="section">
<h2>Photography Tips for Celestial Events</h2>
<div class="photo-tips" id="photoTips">
<p><strong>General Tips:</strong></p>
<ul>
<li><strong>Location:</strong> Choose a dark site away from city lights (light pollution < Bortle 4).</li>
<li><strong>Equipment:</strong> Use a DSLR or smartphone with manual mode, tripod, and optional star tracker.</li>
<li><strong>Settings:</strong> High ISO (800â€“3200), long exposure (5â€“30s), wide aperture (f/2.8 or lower).</li>
<li><strong>Focus:</strong> Set to manual focus, aim at a bright star, and adjust to infinity.</li>
<li><strong>Apps:</strong> Use Stellarium or SkySafari to locate objects.</li>
</ul>
<p id="eventSpecificTips"><strong>Event-Specific Tips:</strong> Detecting conditions...</p>
</div>
</div>

<div class="section">
<h2>ISS Live Feed</h2>
<iframe id="issFeed" src="https://www.youtube.com/embed/EH999s0P1Er0" title="ISS Live Feed" allow="fullscreen" allowfullscreen></iframe>
<div class="iframe-fallback" id="issFallback" style="display: none;">
ISS Live Feed unavailable. Visit <a href="https://www.nasa.gov/nasalive" style="color: #ffca28;">NASA Live</a> for updates.
</div>
</div>

<div class="section">
<h2>Satellite Updates</h2>
<div id="satUpdates">Loading...</div>
</div>
</div>

<script>
// Constants
const UPDATE_INTERVAL = 10000; // 10 seconds for testing (change to 300000 for production)
const SATELLITES = [
    { name: "DSCOVR", lastUpdate: "02:14 AM ADT" },
    { name: "ACE", lastUpdate: "02:13 AM ADT" },
    { name: "SOHO", lastUpdate: "02:12 AM ADT" },
    { name: "SDO", lastUpdate: "02:15 AM ADT" },
    { name: "GOES-19", lastUpdate: "02:14 AM ADT" },
    { name: "STEREO-A", lastUpdate: "02:11 AM ADT" }
];

// Global State
let currentKp = 4;
let solarWind = { speed: 458, density: 5.4, bz: -8.5 };
let flareProbs = { c: 65, m: 25, x: 8, proton: 3 };
let astroData = {
    sun: { rise: "04:50 AM ADT", set: "08:10 PM ADT" },
    moon: { rise: "12:30 AM ADT", set: "08:08 AM ADT", illum: 81 }
};
let weatherForecast = [];
let userTimezone = "ADT";
let userLocation = "Halifax, NS";
let lastUpdateTime = new Date().toLocaleTimeString("en-US", { timeZone: "America/Halifax", hour12: true }) + " ADT";

// Chart Setup (Doughnut styled as gauge)
const ctx = document.getElementById('kpChart').getContext('2d');
const kpChart = new Chart(ctx, {
    type: 'doughnut',
    data: {
        datasets: [{
            data: [currentKp, 9 - currentKp],
            backgroundColor: [getKpColor(currentKp), '#555555'],
            borderColor: '#FFFFFF',
            borderWidth: 2
        }],
        labels: ['Kp Index', 'Remaining']
    },
    options: {
        responsive: true,
        circumference: 180,
        rotation: -90,
        cutout: '80%',
        plugins: {
            title: { display: true, text: "Current Kp Index (Live)", color: "#FFFFFF" },
            legend: { display: false },
            tooltip: { enabled: false }
        }
    }
});

// Functions
function fetchSatelliteData() {
    let kpSum = 0, speedSum = 0, densitySum = 0, bzSum = 0;
    let count = 0;

    SATELLITES.forEach(sat => {
        let data = simulateSatelliteReading(sat.name);
        if (data) {
            kpSum += data.kp;
            speedSum += data.speed;
            densitySum += data.density;
            bzSum += data.bz;
            count++;
        }
    });

    if (count === 0) {
        console.error("No valid satellite data. Using fallback values.");
        currentKp = 4;
        solarWind = { speed: 458, density: 5.4, bz: -8.5 };
    } else {
        currentKp = Math.round(kpSum / count);
        solarWind.speed = Math.round(speedSum / count);
        solarWind.density = (densitySum / count).toFixed(1);
        solarWind.bz = (bzSum / count).toFixed(1);
    }

    flareProbs = simulateFlareProbabilities();
    updateDisplay(); // Call updateDisplay after fetching data
}

function simulateSatelliteReading(satellite) {
    let baseKp = 4, baseSpeed = 460, baseDensity = 5.5, baseBz = -9;
    try {
        switch (satellite) {
            case "DSCOVR":
                return { kp: baseKp, speed: baseSpeed, density: baseDensity, bz: baseBz };
            case "ACE":
                return { kp: baseKp - 0.1, speed: baseSpeed - 5, density: baseDensity - 0.2, bz: baseBz + 0.5 };
            case "SOHO":
                return { kp: baseKp + 0.2, speed: baseSpeed + 3, density: baseDensity + 0.1, bz: baseBz - 0.3 };
            case "SDO":
                return { kp: baseKp - 0.05, speed: baseSpeed - 1, density: baseDensity - 0.1, bz: baseBz + 0.2 };
            case "GOES-19":
                return { kp: baseKp, speed: baseSpeed - 2, density: baseDensity - 0.1, bz: baseBz + 0.25 };
            case "STEREO-A":
                return { kp: baseKp + 0.1, speed: baseSpeed + 5, density: baseDensity + 0.2, bz: baseBz - 0.5 };
            default:
                return null;
        }
    } catch (error) {
        console.error(`Error simulating data for ${satellite}:`, error);
        return null;
    }
}

function simulateFlareProbabilities() {
    try {
        return {
            c: 65 - Math.floor(Math.random() * 5),
            m: 25 - Math.floor(Math.random() * 5),
            x: 8 + Math.floor(Math.random() * 3),
            proton: 3 - Math.floor(Math.random() * 2)
        };
    } catch (error) {
        console.error("Error simulating flare probabilities:", error);
        return { c: 65, m: 25, x: 8, proton: 3 };
    }
}

function simulateWeatherForecast(lat, lon) {
    const conditions = ["Sunny", "Cloudy", "Rain", "Snow", "Partly Cloudy"];
    const forecast = [];
    const baseDate = new Date();
    for (let i = 0; i < 5; i++) {
        const date = new Date(baseDate);
        date.setDate(baseDate.getDate() + i);
        const tempHigh = Math.round(10 + Math.random() * 15 - (lat > 50 ? 5 : 0));
        const tempLow = tempHigh - Math.round(5 + Math.random() * 5);
        const precipChance = Math.round(Math.random() * 60);
        const windSpeed = Math.round(10 + Math.random() * 20);
        forecast.push({
            date: date.toLocaleDateString("en-US", { weekday: "short", month: "short", day: "numeric" }),
            condition: conditions[Math.floor(Math.random() * conditions.length)],
            high: tempHigh,
            low: tempLow,
            precipitation: precipChance,
            wind: windSpeed
        });
    }
    return forecast;
}

function formatTime(date) {
    return date.toLocaleTimeString("en-US", { hour: "2-digit", minute: "2-digit", hour12: true }) + ` ${userTimezone}`;
}

function getAstroData(lat, lon) {
    try {
        const now = new Date();
        const sunTimes = SunCalc.getTimes(now, lat, lon);
        const moonTimes = SunCalc.getMoonTimes(now, lat, lon);
        const moonIllum = SunCalc.getMoonIllumination(now);

        return {
            sun: {
                rise: sunTimes.sunrise ? formatTime(sunTimes.sunrise) : "N/A",
                set: sunTimes.sunset ? formatTime(sunTimes.sunset) : "N/A"
            },
            moon: {
                rise: moonTimes.rise ? formatTime(moonTimes.rise) : "N/A",
                set: moonTimes.set ? formatTime(moonTimes.set) : "N/A",
                illum: Math.round(moonIllum.fraction * 100)
            }
        };
    } catch (error) {
        console.error("Error calculating astronomical data:", error);
        return astroData;
    }
}

function isNightTime() {
    try {
        const now = new Date();
        const sunrise = new Date(now.toDateString() + ' ' + astroData.sun.rise.split(' ')[0]);
        const sunset = new Date(now.toDateString() + ' ' + astroData.sun.set.split(' ')[0]);
        return now < sunrise || now > sunset;
    } catch (error) {
        console.error("Error checking nighttime:", error);
        return false;
    }
}

function areConditionsOptimal() {
    try {
        const isNight = isNightTime();
        const lowMoon = astroData.moon.illum < 25;
        const clearWeather = weatherForecast.length > 0 && (
            (weatherForecast[0].condition === "Sunny" || weatherForecast[0].condition === "Partly Cloudy") &&
            weatherForecast[0].precipitation < 10
        );
        const highKp = currentKp >= 5;
        return isNight && (lowMoon || highKp) && clearWeather;
    } catch (error) {
        console.error("Error checking optimal conditions:", error);
        return false;
    }
}

function getPhotographyTips() {
    const isAurora = currentKp >= 5;
    if (isAurora) {
        return `
<strong>Aurora Photography:</strong>
<ul>
<li>Use a wide-angle lens (14â€“24mm) for broad sky coverage.</li>
<li>Set ISO 1600â€“6400, shutter 5â€“15s, aperture f/2.8â€“f/4.</li>
<li>Shoot in RAW for better post-processing.</li>
<li>Include foreground elements (e.g., trees, lakes) for composition.</li>
<li>Check aurora apps like Aurora Alerts for real-time Kp updates.</li>
</ul>
`;
    } else {
        return `
<strong>Stargazing Photography:</strong>
<ul>
<li>Use a 24â€“50mm lens for stars or deep-sky objects.</li>
<li>Set ISO 800â€“3200, shutter 15â€“30s (use 500 rule: 500/focal length = max exposure).</li>
<li>Stack multiple images using software like Starry Landscape Stacker.</li>
<li>Aim for constellations or Milky Way (visible in dark skies).</li>
<li>Use a red flashlight to preserve night vision.</li>
</ul>
`;
    }
}

async function getUserLocation() {
    // Initialize defaults
    userTimezone = "ADT";
    userLocation = "Halifax, NS";
    astroData = getAstroData(44.6488, -63.5752); // Default to Halifax coordinates
    weatherForecast = simulateWeatherForecast(44.6488, -63.5752);

    if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(
            async (position) => {
                const { latitude, longitude } = position.coords;
                userTimezone = Intl.DateTimeFormat().resolvedOptions().timeZone.split('/').pop();
                userLocation = await getLocationName(latitude, longitude);
                astroData = getAstroData(latitude, longitude);
                weatherForecast = simulateWeatherForecast(latitude, longitude);
                updateDisplay();
            },
            (error) => {
                console.error("Geolocation error:", error);
                updateDisplay(); // Call updateDisplay even on error
            }
        );
    } else {
        console.error("Geolocation not supported.");
        updateDisplay(); // Call updateDisplay for unsupported browsers
    }
}

async function getLocationName(lat, lon) {
    return "User Location";
}

function getKpColor(kp) {
    if (kp <= 3) return "#4CAF50";
    if (kp <= 5) return "#FFCA28";
    return "#F44336";
}

function updateDisplay() {
    try {
        document.getElementById('timestamp').textContent = `As of: ${lastUpdateTime || "N/A"}`;
        document.getElementById('timezone').textContent = userTimezone || "Unknown";
        document.getElementById('location').textContent = userLocation || "Unknown";
        document.getElementById('speed').textContent = solarWind.speed || "N/A";
        document.getElementById('density').textContent = solarWind.density || "N/A";
        document.getElementById('bz').textContent = solarWind.bz || "N/A";
        document.getElementById('cFlare').textContent = flareProbs.c || "N/A";
        document.getElementById('mFlare').textContent = flareProbs.m || "N/A";
        document.getElementById('xFlare').textContent = flareProbs.x || "N/A";
        document.getElementById('proton').textContent = flareProbs.proton || "N/A";
        document.getElementById('sunRise').textContent = astroData.sun.rise || "N/A";
        document.getElementById('sunSet').textContent = astroData.sun.set || "N/A";
        document.getElementById('moonRise').textContent = astroData.moon.rise || "N/A";
        document.getElementById('moonSet').textContent = astroData.moon.set || "N/A";
        document.getElementById('moonIllum').textContent = astroData.moon.illum || "N/A";

        // Update Weather Forecast
        const forecastBody = document.getElementById('forecastBody');
        forecastBody.innerHTML = '';
        if (weatherForecast.length > 0) {
            weatherForecast.forEach(day => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${day.date || "N/A"}</td>
                    <td>${day.condition || "N/A"}</td>
                    <td>${day.high || "N/A"}</td>
                    <td>${day.low || "N/A"}</td>
                    <td>${day.precipitation || "N/A"}%</td>
                    <td>${day.wind || "N/A"}</td>
                `;
                forecastBody.appendChild(row);
            });
        } else {
            forecastBody.innerHTML = '<tr><td colspan="6">No forecast available</td></tr>';
        }

        // Update Optimal Conditions Alert
        const alertDiv = document.getElementById('optimalAlert');
        alertDiv.style.display = areConditionsOptimal() ? 'block' : 'none';

        // Update Photography Tips
        document.getElementById('eventSpecificTips').innerHTML = getPhotographyTips();

        // Update Kp Number
        const kpNumber = document.getElementById('kpNumber');
        kpNumber.textContent = currentKp || "0";
        kpNumber.style.color = getKpColor(currentKp);
        kpNumber.classList.remove('kp-glow-yellow', 'kp-glow-red');
        if (currentKp > 3 && currentKp <= 5) {
            kpNumber.classList.add('kp-glow-yellow');
        } else if (currentKp > 5) {
            kpNumber.classList.add('kp-glow-red');
        }

        // Update Satellite Updates
        document.getElementById('satUpdates').textContent = SATELLITES.map(s => `${s.name}: ${s.lastUpdate}`).join(", ") || "No satellite data";

        // Update Chart
        kpChart.data.datasets[0].data = [currentKp || 0, 9 - (currentKp || 0)];
        kpChart.data.datasets[0].backgroundColor = [getKpColor(currentKp), '#555555'];
        kpChart.update();

        // Debugging logs (uncomment for testing)
        // console.log("Updated display:", { solarWind, currentKp, flareProbs, userTimezone, userLocation, astroData, weatherForecast });
    } catch (error) {
        console.error("Error updating display:", error);
    }
}

// Check ISS Feed Load
const issIframe = document.getElementById('issFeed');
issIframe.onload = () => {
    document.getElementById('issFallback').style.display = 'none';
};
issIframe.onerror = () => {
    document.getElementById('issFallback').style.display = 'block';
};

// Initial Setup
try {
    fetchSatelliteData();
    getUserLocation();
    updateDisplay(); // Call immediately to show initial data
} catch (error) {
    console.error("Initial setup failed:", error);
    updateDisplay();
}

// Update Loop
setInterval(() => {
    try {
        lastUpdateTime = new Date().toLocaleTimeString("en-US", { timeZone: "America/Halifax", hour12: true }) + " ADT";
        fetchSatelliteData();
        // updateDisplay is called within fetchSatelliteData
    } catch (error) {
        console.error("Update loop error:", error);
    }
}, UPDATE_INTERVAL);
</script>
</body>
</html>
