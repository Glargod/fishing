<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cosmos 482 Re-entry Simulation (Intersects Cities with Orbital Pattern)</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        body { margin: 0; font-family: Arial, sans-serif; }
        #map { height: 100vh; width: 100%; }
        #info { position: absolute; top: 10px; left: 10px; background: rgba(255, 255, 255, 0.8); padding: 10px; border-radius: 5px; }
        .uct-effect { color: #ff4500; font-weight: bold; }
        .city-marker { background: #00ff00; border-radius: 50%; width: 10px; height: 10px; }
    </style>
</head>
<body>
    <div id="map"></div>
    <div id="info">
        <h3>Cosmos 482 Re-entry Simulation</h3>
        <p>Time (ADT): <span id="current-time"></span></p>
        <p>Position: <span id="position"></span></p>
        <p>Status: <span id="status">Orbiting</span></p>
        <p class="uct-effect">UCT Effects: Magnetic bias (Â±50Â°), Charge-heat trail</p>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        // Initialize map centered on Indian Ocean
        const map = L.map('map').setView([0, 90], 2);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: 'Â© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>'
        }).addTo(map);

        // Orbital parameters
        const inclination = 51.95; // degrees
        const period = 88 * 60; // seconds (~88 minutes)
        const angularVelocity = (2 * Math.PI) / period; // radians/second
        const earthRotation = 15 / 3600; // degrees/second (15Â°/hour)
        const startTime = new Date('2025-05-10T03:18:00-03:00').getTime(); // 03:18 AM ADT
        const nominalTime = new Date('2025-05-10T03:28:00-03:00').getTime(); // 03:28 AM ADT
        const endTime = new Date('2025-05-10T05:52:00-03:00').getTime(); // 05:52 AM ADT
        const totalTime = 2.69 * period; // Total simulation time (~2.69 orbits)

        // Cities with adjusted times to match trajectory intersections
        const cities = [
            { name: 'Port Blair', lat: 11.6, lon: 92.7, time: '2025-05-10T03:49:00-03:00' }, // t = 1875 s
            { name: 'Urumqi', lat: 43.8, lon: 87.6, time: '2025-05-10T04:10:00-03:00' }, // t = 3115 s
            { name: 'Almaty', lat: 43.3, lon: 76.9, time: '2025-05-10T04:19:00-03:00' }, // t = 3660 s
            { name: 'MalÃ©', lat: 4.2, lon: 73.5, time: '2025-05-10T04:23:00-03:00' }, // Adjusted
            { name: 'Tashkent', lat: 41.3, lon: 69.2, time: '2025-05-10T04:27:00-03:00' },
            { name: 'Tehran', lat: 35.7, lon: 51.4, time: '2025-05-10T04:44:00-03:00' },
            { name: 'Mogadishu', lat: 2.0, lon: 45.3, time: '2025-05-10T04:50:00-03:00' },
            { name: 'Nairobi', lat: -1.3, lon: 36.8, time: '2025-05-10T04:59:00-03:00' },
            { name: 'Kyiv', lat: 50.4, lon: 30.5, time: '2025-05-10T05:07:00-03:00' }
        ];

        // Plot cities
        cities.forEach(city => {
            const marker = L.circleMarker([city.lat, city.lon], {
                radius: 5,
                color: '#00ff00',
                fillOpacity: 0.8
            }).addTo(map);
            marker.bindTooltip(`${city.name}<br>${new Date(city.time).toLocaleTimeString('en-US', { timeZone: 'America/Halifax' })} ADT`);
        });

        // Generate full ground tracks for each orbit
        const startLon = 100.5; // Adjusted to align with re-entry
        const corridorWidth = 2;
        const orbits = Math.ceil(totalTime / period);
        const groundTracks = [];
        const corridors = [];
        const phaseOffset = -0.714; // Align perigee with 03:28 AM ADT

        for (let orbit = 0; orbit < orbits; orbit++) {
            const track = [];
            const corridor = [];
            const lonOffset = earthRotation * (orbit * period);

            // Plot full 360Â° orbit
            for (let t = 0; t <= period; t += 10) {
                const phase = angularVelocity * t + phaseOffset;
                const lat = inclination * Math.sin(phase);
                const orbitalLon = (startLon + 360 * (t / period)) % 360;
                const groundLon = (orbitalLon - (earthRotation * (t + orbit * period))) % 360;
                const adjustedLon = groundLon < -180 ? groundLon + 360 : groundLon;
                track.push([lat, adjustedLon]);
                corridor.push([lat + corridorWidth, adjustedLon]);
                corridor.push([lat - corridorWidth, adjustedLon]);
            }

            groundTracks.push(track);
            corridors.push(corridor);
        }

        // Plot each orbit's ground track and corridor
        groundTracks.forEach((track, index) => {
            L.polyline(track, { color: '#0000ff', weight: 2, opacity: 0.5 }).addTo(map);
            L.polyline(track, { color: '#ff4500', weight: 4, opacity: 0.2 }).addTo(map);
            L.polygon(corridors[index], { color: '#0000ff', fillOpacity: 0.05 }).addTo(map);
        });

        // Plot active segments with adjusted longitude progression
        const activeTracks = [];
        const activeCorridors = [];
        for (let orbit = 0; orbit < orbits; orbit++) {
            const activeTrack = [];
            const activeCorridor = [];
            const orbitStartTime = orbit * period;
            const orbitEndTime = Math.min((orbit + 1) * period, totalTime);
            for (let t = orbitStartTime; t <= orbitEndTime; t += 10) {
                const phase = angularVelocity * (t - orbitStartTime) + phaseOffset;
                const lat = inclination * Math.sin(phase);
                const groundLon = (startLon - (earthRotation * t)) % 360;
                const adjustedLon = groundLon < -180 ? groundLon + 360 : groundLon;
                activeTrack.push([lat, adjustedLon]);
                activeCorridor.push([lat + corridorWidth, adjustedLon]);
                activeCorridor.push([lat - corridorWidth, adjustedLon]);
            }
            activeTracks.push(activeTrack);
            activeCorridors.push(activeCorridor);
        }

        // Plot active segments with higher opacity
        activeTracks.forEach((track, index) => {
            L.polyline(track, { color: '#0000ff', weight: 2 }).addTo(map);
            L.polyline(track, { color: '#ff4500', weight: 4, opacity: 0.3 }).addTo(map);
            L.polygon(activeCorridors[index], { color: '#0000ff', fillOpacity: 0.1 }).addTo(map);
        });

        // Nominal re-entry marker
        const nominalLat = 0;
        const nominalLon = 98;
        L.marker([nominalLat, nominalLon], {
            icon: L.divIcon({ className: 'uct-effect', html: '<div style="color:red;font-size:20px;">ðŸ”¥</div>' })
        }).addTo(map).bindTooltip('Nominal Re-entry: 03:28 AM ADT');

        // Real-time spacecraft marker
        let spacecraftMarker = L.circleMarker([0, startLon], {
            radius: 7,
            color: '#ff0000',
            fillOpacity: 1
        }).addTo(map).bindTooltip('Cosmos 482');

        // Real-time simulation
        function updateSimulation() {
            const now = new Date().getTime();
            const elapsed = (now - startTime) / 1000;
            const orbitNumber = Math.floor(elapsed / period);
            const orbitElapsed = elapsed % period;
            const phase = angularVelocity * orbitElapsed + phaseOffset;
            const lat = inclination * Math.sin(phase);
            const groundLon = (startLon - (earthRotation * elapsed)) % 360;
            const adjustedLon = groundLon < -180 ? groundLon + 360 : groundLon;

            // Update marker
            spacecraftMarker.setLatLng([lat, adjustedLon]);
            spacecraftMarker.setTooltipContent(`Cosmos 482<br>Lat: ${lat.toFixed(2)}Â°<br>Lon: ${adjustedLon.toFixed(2)}Â°`);

            // Update info panel
            document.getElementById('current-time').textContent = new Date().toLocaleString('en-US', { timeZone: 'America/Halifax' });
            document.getElementById('position').textContent = `Lat: ${lat.toFixed(2)}Â°, Lon: ${adjustedLon.toFixed(2)}Â°`;
            document.getElementById('status').textContent = now < nominalTime ? 'Orbiting' : now < endTime ? 'Re-entering' : 'Landed';

            // Stop if past window
            if (now > new Date('2025-05-10T07:15:00-03:00').getTime()) {
                document.getElementById('status').textContent = 'Simulation Ended';
                clearInterval(interval);
            }
        }

        // Run every second
        updateSimulation();
        const interval = setInterval(updateSimulation, 1000);
    </script>
</body>
</html>
