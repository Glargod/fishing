<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cosmos 482 Re-entry Simulation (Parallel Tracks)</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        body { margin: 0; font-family: Arial, sans-serif; }
        #map { height: 100vh; width: 100%; }
        #info { position: absolute; top: 10px; left: 10px; background: rgba(255, 255, 255, 0.8); padding: 10px; border-radius: 5px; }
        .uct-effect { color: #ff4500; font-weight: bold; }
        .city-marker { background: #00ff00; border-radius: 50%; width: 10px; height: 10px; }
    </style>
</head>
<body>
    <div id="map"></div>
    <div id="info">
        <h3>Cosmos 482 Re-entry Simulation</h3>
        <p>Time (ADT): <span id="current-time"></span></p>
        <p>Position: <span id="position"></span></p>
        <p>Status: <span id="status">Orbiting</span></p>
        <p class="uct-effect">UCT Effects: Magnetic bias (Â±50Â°), Charge-heat trail</p>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        // Initialize map centered on Indian Ocean
        const map = L.map('map').setView([0, 90], 3);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: 'Â© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>'
        }).addTo(map);

        // Orbital parameters
        const inclination = 51.95; // degrees
        const period = 88 * 60; // seconds (~88 minutes)
        const angularVelocity = (2 * Math.PI) / period; // radians/second
        const earthRotation = 15 / 3600; // degrees/second (15Â°/hour)
        const startTime = new Date('2025-05-10T03:18:00-03:00').getTime(); // 03:18 AM ADT
        const nominalTime = new Date('2025-05-10T03:28:00-03:00').getTime(); // 03:28 AM ADT
        const endTime = new Date('2025-05-10T05:52:00-03:00').getTime(); // 05:52 AM ADT
        const totalTime = 2.69 * period; // Total simulation time (~2.69 orbits)

        // Cities in chronological order with lat/lon and ADT times
        const cities = [
            { name: 'Port Blair', lat: 11.6, lon: 92.7, time: '2025-05-10T03:20:00-03:00' },
            { name: 'Urumqi', lat: 43.8, lon: 87.6, time: '2025-05-10T03:38:00-03:00' },
            { name: 'Almaty', lat: 43.3, lon: 76.9, time: '2025-05-10T03:40:00-03:00' },
            { name: 'MalÃ©', lat: 4.2, lon: 73.5, time: '2025-05-10T04:44:00-03:00' },
            { name: 'Tashkent', lat: 41.3, lon: 69.2, time: '2025-05-10T05:06:00-03:00' },
            { name: 'Tehran', lat: 35.7, lon: 51.4, time: '2025-05-10T06:12:00-03:00' },
            { name: 'Mogadishu', lat: 2.0, lon: 45.3, time: '2025-05-10T06:58:00-03:00' },
            { name: 'Nairobi', lat: -1.3, lon: 36.8, time: '2025-05-10T07:00:00-03:00' },
            { name: 'Kyiv', lat: 50.4, lon: 30.5, time: '2025-05-10T07:14:00-03:00' }
        ];

        // Plot cities
        cities.forEach(city => {
            const marker = L.circleMarker([city.lat, city.lon], {
                radius: 5,
                color: '#00ff00',
                fillOpacity: 0.8
            }).addTo(map);
            marker.bindTooltip(`${city.name}<br>${new Date(city.time).toLocaleTimeString('en-US', { timeZone: 'America/Halifax' })} ADT`);
        });

        // Generate ground tracks for each orbit
        const startLon = 100; // Starting longitude at 03:18 AM ADT (~100Â°E)
        const corridorWidth = 2; // ~2Â° â‰ˆ 200 km at equator (approximation for 90â€“450 km corridor)
        const orbits = Math.ceil(totalTime / period); // Number of orbits (3)
        const groundTracks = [];
        const corridors = [];

        for (let orbit = 0; orbit < orbits; orbit++) {
            const track = [];
            const corridor = [];
            const orbitStartTime = orbit * period;
            const orbitEndTime = Math.min((orbit + 1) * period, totalTime);
            const lonOffset = earthRotation * orbitStartTime; // Westward shift for this orbit

            for (let t = orbitStartTime; t <= orbitEndTime; t += 10) {
                const phase = angularVelocity * (t - orbitStartTime); // Phase for this orbit
                const lat = inclination * Math.sin(phase); // Sinusoidal latitude
                const lon = startLon - (earthRotation * t) % 360; // Westward shift
                const adjustedLon = lon < -180 ? lon + 360 : lon;
                track.push([lat, adjustedLon]);
                // Corridor points
                corridor.push([lat + corridorWidth, adjustedLon]);
                corridor.push([lat - corridorWidth, adjustedLon]);
            }

            groundTracks.push(track);
            corridors.push(corridor);
        }

        // Plot each orbit's ground track and corridor
        groundTracks.forEach((track, index) => {
            L.polyline(track, { color: '#0000ff', weight: 2 }).addTo(map); // Blue track
            L.polyline(track, { color: '#ff4500', weight: 4, opacity: 0.3 }).addTo(map); // UCT charge-heat trail
            L.polygon(corridors[index], { color: '#0000ff', fillOpacity: 0.1 }).addTo(map); // Corridor
        });

        // Nominal re-entry marker
        const nominalLat = 0; // Expected at equator (perigee)
        const nominalLon = 98; // ~98Â°E at 03:28 AM ADT
        L.marker([nominalLat, nominalLon], {
            icon: L.divIcon({ className: 'uct-effect', html: '<div style="color:red;font-size:20px;">ðŸ”¥</div>' })
        }).addTo(map).bindTooltip('Nominal Re-entry: 03:28 AM ADT');

        // Real-time spacecraft marker
        let spacecraftMarker = L.circleMarker([0, startLon], {
            radius: 7,
            color: '#ff0000',
            fillOpacity: 1
        }).addTo(map).bindTooltip('Cosmos 482');

        // Real-time simulation
        function updateSimulation() {
            const now = new Date().getTime();
            const elapsed = (now - startTime) / 1000; // Seconds since 03:18 AM ADT
            const orbitNumber = Math.floor(elapsed / period); // Current orbit
            const orbitElapsed = elapsed % period; // Time within current orbit
            const phase = angularVelocity * orbitElapsed; // Phase within current orbit
            // Bias latitude toward perigee (equator)
            const lat = inclination * Math.sin(phase) * (1 - 0.7 * Math.cos(phase));
            const lon = startLon - (earthRotation * elapsed) % 360; // Current longitude
            const adjustedLon = lon < -180 ? lon + 360 : lon;

            // Update marker
            spacecraftMarker.setLatLng([lat, adjustedLon]);
            spacecraftMarker.setTooltipContent(`Cosmos 482<br>Lat: ${lat.toFixed(2)}Â°<br>Lon: ${adjustedLon.toFixed(2)}Â°`);

            // Update info panel
            document.getElementById('current-time').textContent = new Date().toLocaleString('en-US', { timeZone: 'America/Halifax' });
            document.getElementById('position').textContent = `Lat: ${lat.toFixed(2)}Â°, Lon: ${adjustedLon.toFixed(2)}Â°`;
            document.getElementById('status').textContent = now < nominalTime ? 'Orbiting' : now < endTime ? 'Re-entering' : 'Landed';

            // Stop if past window
            if (now > new Date('2025-05-10T07:15:00-03:00').getTime()) {
                document.getElementById('status').textContent = 'Simulation Ended';
                clearInterval(interval);
            }
        }

        // Run every second
        updateSimulation();
        const interval = setInterval(updateSimulation, 1000);
    </script>
</body>
</html>
